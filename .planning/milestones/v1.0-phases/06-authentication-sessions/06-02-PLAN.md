---
phase: 06-authentication-sessions
plan: 02
type: execute
wave: 2
depends_on:
  - "06-01"
files_modified:
  - src/crawl4ai_mcp/server.py
  - tests/test_sessions.py
autonomous: true
requirements:
  - AUTH-03

must_haves:
  truths:
    - "Claude can call list_sessions and see all active named sessions with their age"
    - "Claude can call destroy_session with a session_id and the session is closed and removed"
    - "destroy_session returns an error message if the session_id does not exist"
    - "list_sessions returns a meaningful message when no sessions are active"
  artifacts:
    - path: "src/crawl4ai_mcp/server.py"
      provides: "list_sessions and destroy_session MCP tools"
      contains: "def list_sessions"
    - path: "tests/test_sessions.py"
      provides: "Unit tests for session tracking logic"
  key_links:
    - from: "destroy_session"
      to: "crawler.crawler_strategy.kill_session"
      via: "async call to kill_session with session_id"
      pattern: "kill_session"
    - from: "list_sessions"
      to: "AppContext.sessions"
      via: "iterates sessions dict"
      pattern: "app\\.sessions"
---

<objective>
Add `list_sessions` and `destroy_session` MCP tools and unit tests for the session management system.

Purpose: Claude needs to inspect which sessions are active (to know what is available) and destroy sessions when they are no longer needed (to free browser resources). These tools complete the AUTH-03 requirement and close out Phase 6.

Output: `list_sessions` and `destroy_session` MCP tools, unit tests for session tracking.
</objective>

<execution_context>
@/Users/brianpotter/.claude/get-shit-done/workflows/execute-plan.md
@/Users/brianpotter/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-authentication-sessions/06-RESEARCH.md
@.planning/phases/06-authentication-sessions/06-01-SUMMARY.md
@src/crawl4ai_mcp/server.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add list_sessions and destroy_session MCP tools</name>
  <files>src/crawl4ai_mcp/server.py</files>
  <action>
1. Add the `list_sessions` MCP tool. Place it after `create_session` and before `crawl_many`:

   ```python
   @mcp.tool()
   async def list_sessions(
       ctx: Context[ServerSession, AppContext] = None,
   ) -> str:
       """List all active named browser sessions.

       Shows each session's name and how long ago it was created.
       Sessions have a 30-minute inactivity TTL managed by crawl4ai —
       a session may have been auto-expired by crawl4ai even if it
       still appears here. The next crawl_url call with an expired
       session_id will transparently create a fresh session.
       """
       app: AppContext = ctx.request_context.lifespan_context
       if not app.sessions:
           return "No active sessions."

       lines = ["Active sessions:"]
       now = time.time()
       for sid, created in sorted(app.sessions.items()):
           age_mins = (now - created) / 60
           lines.append(f"  - {sid} (created {age_mins:.0f} min ago)")
       return "\n".join(lines)
   ```

2. Add the `destroy_session` MCP tool immediately after `list_sessions`:

   ```python
   @mcp.tool()
   async def destroy_session(
       session_id: str,
       ctx: Context[ServerSession, AppContext] = None,
   ) -> str:
       """Destroy a named browser session and free its resources.

       Closes the session's browser page and context. The session_id
       can no longer be used with crawl_url after destruction.

       Args:
           session_id: The session name to destroy. Use list_sessions
               to see available sessions.
       """
       app: AppContext = ctx.request_context.lifespan_context
       if session_id not in app.sessions:
           return f"Session not found: {session_id}"

       logger.info("destroy_session: %s", session_id)
       try:
           await app.crawler.crawler_strategy.kill_session(session_id)
       except Exception as exc:
           logger.warning("Error killing session %s: %s", session_id, exc)
       del app.sessions[session_id]
       return f"Session destroyed: {session_id}"
   ```

   NOTE: The `try/except` around `kill_session` is intentional — if crawl4ai already auto-expired the session (30-min TTL), the kill call may fail. We still remove it from our tracking dict.
  </action>
  <verify>
    `uv run ruff check src/` passes.
    `grep -n "def list_sessions\|def destroy_session" src/crawl4ai_mcp/server.py` shows both tools.
  </verify>
  <done>
    list_sessions tool returns formatted list of active sessions with age. destroy_session tool kills the browser session and removes it from tracking. Both handle edge cases (empty list, missing session_id).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for session tracking</name>
  <files>tests/test_sessions.py</files>
  <action>
Create `tests/test_sessions.py` with unit tests that validate the session tracking logic without requiring a live browser. Use the existing test patterns from the project (pytest, mock).

Tests to write:

1. **test_app_context_sessions_field**: Verify AppContext can be instantiated with a sessions dict and it defaults correctly.

2. **test_session_tracking_register**: Create an AppContext with mock crawler and profile_manager. Add entries to `sessions` dict. Verify they appear and have reasonable timestamps.

3. **test_session_tracking_destroy_removes_entry**: Add a session to the dict, simulate destroy by deleting the entry, verify it is gone.

4. **test_list_sessions_empty**: Verify the output message when sessions dict is empty ("No active sessions.").

5. **test_list_sessions_with_entries**: Add 2-3 sessions to the dict with known timestamps, verify the formatted output includes all session names and age information.

6. **test_destroy_session_not_found**: Verify behavior when trying to destroy a non-existent session_id.

Implementation approach — test the logic directly rather than through MCP tool dispatch:
```python
import time
import pytest
from unittest.mock import AsyncMock, MagicMock
from crawl4ai_mcp.server import AppContext

def _make_app_context():
    """Create an AppContext with mocked crawler and profile_manager."""
    crawler = MagicMock()
    crawler.crawler_strategy = MagicMock()
    crawler.crawler_strategy.kill_session = AsyncMock()
    profile_manager = MagicMock()
    return AppContext(crawler=crawler, profile_manager=profile_manager, sessions={})

def test_app_context_sessions_field():
    app = _make_app_context()
    assert app.sessions == {}
    assert isinstance(app.sessions, dict)

def test_session_tracking_register():
    app = _make_app_context()
    now = time.time()
    app.sessions["test-session"] = now
    assert "test-session" in app.sessions
    assert app.sessions["test-session"] == now

def test_session_tracking_destroy_removes_entry():
    app = _make_app_context()
    app.sessions["doomed"] = time.time()
    del app.sessions["doomed"]
    assert "doomed" not in app.sessions

def test_list_sessions_empty_message():
    app = _make_app_context()
    assert not app.sessions  # Empty dict is falsy

def test_list_sessions_formatting():
    app = _make_app_context()
    app.sessions["alpha"] = time.time() - 300  # 5 min ago
    app.sessions["beta"] = time.time() - 60    # 1 min ago
    # Verify both sessions present and sorted
    sorted_keys = sorted(app.sessions.keys())
    assert sorted_keys == ["alpha", "beta"]

@pytest.mark.asyncio
async def test_destroy_session_calls_kill():
    app = _make_app_context()
    app.sessions["my-session"] = time.time()
    await app.crawler.crawler_strategy.kill_session("my-session")
    del app.sessions["my-session"]
    app.crawler.crawler_strategy.kill_session.assert_called_once_with("my-session")
    assert "my-session" not in app.sessions
```

Ensure `pytest-asyncio` is available (it should be from existing test setup). If not, add it.
  </action>
  <verify>
    `uv run pytest tests/test_sessions.py -v` — all tests pass.
    `uv run pytest` — full test suite passes (no regressions).
    `uv run ruff check tests/` — no lint issues.
  </verify>
  <done>
    Unit tests validate session tracking: AppContext.sessions field exists, entries can be added and removed, destroy calls kill_session on the crawler strategy. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `uv run ruff check src/ tests/` — no lint errors
2. `uv run pytest` — full test suite passes
3. `uv run pytest tests/test_sessions.py -v` — session tests pass individually
4. `grep -c "def list_sessions\|def destroy_session\|def create_session" src/crawl4ai_mcp/server.py` — all 3 session tools present
5. All 3 AUTH requirements are covered: AUTH-01 (cookies param, already working + verified with session_id), AUTH-02 (session_id on crawl_url + create_session), AUTH-03 (list_sessions + destroy_session)
</verification>

<success_criteria>
- list_sessions tool exists and returns formatted session list or "No active sessions."
- destroy_session tool exists and kills the session via crawler_strategy.kill_session
- destroy_session handles non-existent session_id gracefully
- Unit tests for session tracking pass
- All existing tests pass (no regressions)
- No print() calls or stdout corruption
</success_criteria>

<output>
After completion, create `.planning/phases/06-authentication-sessions/06-02-SUMMARY.md`
</output>
